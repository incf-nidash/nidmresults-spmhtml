%==========================================================================
%Generate an object with the same format as the SPM-output variable, SPM, 
%using the information from an input NIDM-Results json pack. This takes in 
%the following arguments:
%
%graph - the nidm-results graph
%filepathTemp - the filepath to the NIDM pack.
%typemap - a hashmap generated by the addtypepointers function.
%ids - a list of ids in the graph. 
%exObj - an object containing all information about multiple excursions 
%sets.
%
%Authors: Thomas Maullin, Camille Maumet.
%==========================================================================

function NSPM = changeNIDMtoSPM(graph, filepathTemp, typemap, context, ids, exObj)

    % Checking inputs.
    if nargin < 6
        multipleExcursions = false;
    end
    if nargin == 6
        multipleExcursions = true;
        exID = exObj{1};
        exLabels = exObj{2};
    end
    
    NSPM = struct;
    
    %======================================================================
    %nidm - NOTE: In the standard format for the SPM file the design
    %matrix is derived from other fields and this field does not exist.
    
    nidmTemp = struct;
    designMatrix = typemap(context('nidm_DesignMatrix'));
    if(multipleExcursions)
        designMatrix = relevantToExcursion(designMatrix, exID, exLabels);
    end
    
    % Find the location of the design matrix (case depends on the version of 
    % the exporter, in the future we should look at the URI to avoid relying on 
    % attribute names)
    if isfield(designMatrix{1}, 'dc_description')
        locationID = searchforID(designMatrix{1}.('dc_description').('x_id'), graph, ids);
    elseif isfield(designMatrix{1}, 'dc_Description')
        locationID = searchforID(designMatrix{1}.('dc_Description').('x_id'), graph, ids);
    end
    nidmTemp.DesMat = getPathDetails(get_value(locationID.('prov_atLocation')), filepathTemp);
    
    %Read the csv file and obtain it's dimensions.
    csvFilePath = getPathDetails(get_value(designMatrix{1}.('prov_atLocation')), filepathTemp);
    csvFile = csvread(csvFilePath);
    nidmTemp.dim = size(csvFile);
    
    %======================================================================
    %xCon
    
    xConTemp = struct;
    
    %Search for contrastwieght matrix objects to obtain a contrast vector.
    contrastWeightMatrix = typemap(context('obo_ContrastWeightMatrix'));
    if(multipleExcursions)
        contrastWeightMatrix = relevantToExcursion(contrastWeightMatrix, exID, exLabels);
    end
    
    %Get the StatType and statisticMaps
    if(multipleExcursions)
        [xConTemp.STAT, statisticMaps] = getStatType(typemap, context, exID, exLabels);
    else
        [xConTemp.STAT, statisticMaps] = getStatType(typemap, context);
    end 
    
    %Retrieve contrast name.
    if(~isempty(statisticMaps))
        for i = 1:length(statisticMaps)
            if isfield(statisticMaps{i}, 'nidm_contrastName')
                xConTemp.name = get_value(statisticMaps{i}.('nidm_contrastName'));
            end
        end 
    else
        xConTemp.name = '';
    end
    
    xConTemp(1).c = str2num(get_value(contrastWeightMatrix{1}.('prov_value')))';
    
    % Check if we are dealing with an F contrast with multiple rows.
    if size(xConTemp(1).c,1) ~= nidmTemp.dim(2)
        % If we are the contrast will need reshaping. (Othewise everything
        % will appear on one row).
        xConTemp(1).c = reshape(xConTemp(1).c, nidmTemp.dim(2), size(xConTemp(1).c,1)/nidmTemp.dim(2));
    end
    
    %======================================================================
    %xX
    
    xXtemp = struct;
    
    %Find the design matrix csv.
    designMatrixFilename = get_value(designMatrix{1}.prov_atLocation);
    [~, name, ext] = fileparts(designMatrixFilename);
    xXtemp.xKXs.X = csvread(fullfile(filepathTemp, [name, ext]));
    
    %Record the SVD data.
    [xXtemp.xKXs.u, ds, xXtemp.xKXs.v] = svd(xXtemp.xKXs.X, 0);
    xXtemp.xKXs.ds = diag(ds);
    xXtemp.xKXs.tol = max(size(xXtemp.xKXs.X))*max(abs(xXtemp.xKXs.ds))*eps;
    xXtemp.xKXs.rk = rank(xXtemp.xKXs.X);
    
    %These variables are not required to be recorded in SPM but can cause 
    %errors if not set.
    xXtemp.xKXs.oP = [];
    xXtemp.xKXs.oPp = [];
    xXtemp.xKXs.ups = [];
    xXtemp.xKXs.sus = [];
    
    %Get the regressor names in required format.
    remain = strrep(strrep(strrep(strrep(get_value(designMatrix{1}.nidm_regressorNames), '\"', ''), '[', ''), ']', ''), ',', '');

    % Deal with the case of empty regressor names
    if isempty(remain)
        regNameCell{1} = '';
    else
        regNameCell = {};
        while ~isempty(remain)
            [token, remain] = strtok(remain, ' ');
            regNameCell{end+1} = token;
        end
    end
    
    xXtemp.name = regNameCell;
    
    %Create the nKX design matrix.
    xXtemp.nKX = spm_DesMtx('sca',xXtemp.xKXs.X,xXtemp.name);
    
    %======================================================================
    %Assign fields of NSPM.
    
    NSPM.nidm = nidmTemp;
    NSPM.xCon = xConTemp;
    NSPM.xX = xXtemp;
    NSPM.nidm.filepath = filepathTemp;
    
end
